'use strict';

var fp = require('lodash/fp');
var clientS3 = require('@aws-sdk/client-s3');
var s3RequestPresigner = require('@aws-sdk/s3-request-presigner');
var libStorage = require('@aws-sdk/lib-storage');

const ENDPOINT_PATTERN = /^(.+\.)?s3[.-]([a-z0-9-]+)\./;
function isUrlFromBucket(fileUrl, bucketName, baseUrl = '') {
    const url = new URL(fileUrl);
    // Check if the file URL is using a base URL (e.g. a CDN).
    // In this case do not sign the URL.
    if (baseUrl) {
        return false;
    }
    const { bucket } = getBucketFromAwsUrl(fileUrl);
    if (bucket) {
        return bucket === bucketName;
    }
    // File URL might be of an S3-compatible provider. (or an invalid URL)
    // In this case, check if the bucket name appears in the URL host or path.
    // e.g. https://minio.example.com/bucket-name/object-key
    // e.g. https://bucket.nyc3.digitaloceanspaces.com/folder/img.png
    return url.host.startsWith(`${bucketName}.`) || url.pathname.includes(`/${bucketName}/`);
}
/**
 * Parse the bucket name from a URL.
 * See all URL formats in https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html
 *
 * @param {string} fileUrl - the URL to parse
 * @returns {object} result
 * @returns {string} result.bucket - the bucket name
 * @returns {string} result.err - if any
 */ function getBucketFromAwsUrl(fileUrl) {
    const url = new URL(fileUrl);
    // S3://<bucket-name>/<key>
    if (url.protocol === 's3:') {
        const bucket = url.host;
        if (!bucket) {
            return {
                err: `Invalid S3 url: no bucket: ${url}`
            };
        }
        return {
            bucket
        };
    }
    if (!url.host) {
        return {
            err: `Invalid S3 url: no hostname: ${url}`
        };
    }
    const matches = url.host.match(ENDPOINT_PATTERN);
    if (!matches) {
        return {
            err: `Invalid S3 url: hostname does not appear to be a valid S3 endpoint: ${url}`
        };
    }
    const prefix = matches[1];
    // https://s3.amazonaws.com/<bucket-name>
    if (!prefix) {
        if (url.pathname === '/') {
            return {
                bucket: null
            };
        }
        const index = url.pathname.indexOf('/', 1);
        // https://s3.amazonaws.com/<bucket-name>
        if (index === -1) {
            return {
                bucket: url.pathname.substring(1)
            };
        }
        // https://s3.amazonaws.com/<bucket-name>/
        if (index === url.pathname.length - 1) {
            return {
                bucket: url.pathname.substring(1, index)
            };
        }
        // https://s3.amazonaws.com/<bucket-name>/key
        return {
            bucket: url.pathname.substring(1, index)
        };
    }
    // https://<bucket-name>.s3.amazonaws.com/
    return {
        bucket: prefix.substring(0, prefix.length - 1)
    };
}
const extractCredentials = (options)=>{
    if (options.s3Options?.credentials) {
        return {
            accessKeyId: options.s3Options.credentials.accessKeyId,
            secretAccessKey: options.s3Options.credentials.secretAccessKey
        };
    }
    return null;
};

const assertUrlProtocol = (url)=>{
    // Regex to test protocol like "http://", "https://"
    return /^\w*:\/\//.test(url);
};
const getConfig = ({ baseUrl, rootPath, s3Options, ...legacyS3Options })=>{
    if (Object.keys(legacyS3Options).length > 0) {
        process.emitWarning("S3 configuration options passed at root level of the plugin's providerOptions is deprecated and will be removed in a future release. Please wrap them inside the 's3Options:{}' property.");
    }
    const credentials = extractCredentials({
        s3Options,
        ...legacyS3Options
    });
    const config = {
        ...s3Options,
        ...legacyS3Options,
        ...credentials ? {
            credentials
        } : {}
    };
    config.params.ACL = fp.getOr(clientS3.ObjectCannedACL.public_read, [
        'params',
        'ACL'
    ], config);
    return config;
};
var index = {
    init ({ baseUrl, rootPath, s3Options, ...legacyS3Options }) {
        // TODO V5 change config structure to avoid having to do this
        const config = getConfig({
            baseUrl,
            rootPath,
            s3Options,
            ...legacyS3Options
        });
        const s3Client = new clientS3.S3Client(config);
        const filePrefix = rootPath ? `${rootPath.replace(/\/+$/, '')}/` : '';
        const getFileKey = (file)=>{
            const path = file.path ? `${file.path}/` : '';
            return `${filePrefix}${path}${file.hash}${file.ext}`;
        };
        const upload = async (file, customParams = {})=>{
            const fileKey = getFileKey(file);
            const uploadObj = new libStorage.Upload({
                client: s3Client,
                params: {
                    Bucket: config.params.Bucket,
                    Key: fileKey,
                    Body: file.stream || Buffer.from(file.buffer, 'binary'),
                    ACL: config.params.ACL,
                    ContentType: file.mime,
                    ...customParams
                }
            });
            const upload = await uploadObj.done();
            if (assertUrlProtocol(upload.Location)) {
                file.url = baseUrl ? `${baseUrl}/${fileKey}` : upload.Location;
            } else {
                // Default protocol to https protocol
                file.url = `https://${upload.Location}`;
            }
        };
        return {
            isPrivate () {
                return config.params.ACL === 'private';
            },
            async getSignedUrl (file, customParams) {
                // Do not sign the url if it does not come from the same bucket.
                if (!isUrlFromBucket(file.url, config.params.Bucket, baseUrl)) {
                    return {
                        url: file.url
                    };
                }
                const fileKey = getFileKey(file);
                const url = await s3RequestPresigner.getSignedUrl(// @ts-expect-error - TODO fix client type
                s3Client, new clientS3.GetObjectCommand({
                    Bucket: config.params.Bucket,
                    Key: fileKey,
                    ...customParams
                }), {
                    expiresIn: fp.getOr(15 * 60, [
                        'params',
                        'signedUrlExpires'
                    ], config)
                });
                return {
                    url
                };
            },
            uploadStream (file, customParams = {}) {
                return upload(file, customParams);
            },
            upload (file, customParams = {}) {
                return upload(file, customParams);
            },
            delete (file, customParams = {}) {
                const command = new clientS3.DeleteObjectCommand({
                    Bucket: config.params.Bucket,
                    Key: getFileKey(file),
                    ...customParams
                });
                return s3Client.send(command);
            }
        };
    }
};

module.exports = index;
//# sourceMappingURL=index.js.map
